function compareTrackData(newData,oldFile)
% COMPARETRACKDATA Compares new tracking data to old tracking file data
%
% compareTrackData(NEWDATA,OLDFILE) Compares new tracking data in NEWDATA
% generated by trackWithOldData to tracking data in file OLDFILE.  The
% purpose of this function is to test changes to the tracking algorithm. A
% difference signal between several tracked features in the new and old
% data is calculated.  Statistics of this difference signal are displayed
% in the command window.

% Load Old Data
s = load(oldFile); tData = s.saveStruct;

%% Determine Frame Subsets
corrFrames = (tData.label == 0);

% Determine Correct Detection Frames
corrDetect = false(size(corrFrames));
if(corrFrames(1) == 1); corrDetect(1) = 1; end;
for k = 2:numel(corrDetect)
    if((corrFrames(k) == 1) && (corrFrames(k-1) == 0) && ~isnan(tData.label(k)))
        corrDetect(k) = 1;
    end
end

% Determine Correct Tracking Frames
corrTrack = false(size(corrFrames));
for k = 2:numel(corrDetect)
    if((corrFrames(k) == 1) && (corrFrames(k-1) == 1) && ~isnan(tData.label(k)))
        corrTrack(k) = 1;
    end
end

% Determine Tracking Error Frames
errTrack = false(size(corrFrames));
for k = 2:numel(errTrack)
    if((corrFrames(k) == 0) && (corrFrames(k-1) == 1) && ~isnan(tData.label(k)))
        errTrack(k) = 1;
    end
end

% Theta Conversion Factor
cv = (180/pi);

%% Correct Detection
cdf = find(corrDetect); % Frame Numbers

statsAndPlot(newData.mark.subT(corrDetect,1),tData.mark.subT(corrDetect,1),'Correct Detect X_{mark}',cdf);
statsAndPlot(newData.mark.subT(corrDetect,2),tData.mark.subT(corrDetect,2),'Correct Detect Y_{mark}',cdf);
statsAndPlot(newData.inst.rho(corrDetect,1),tData.inst.rho(corrDetect,1),'Correct Detect \rho_l',cdf,1);
statsAndPlot(newData.inst.rho(corrDetect,2),tData.inst.rho(corrDetect,2),'Correct Detect \rho_r',cdf,1);
statsAndPlot(cv*newData.inst.theta(corrDetect,1),cv*tData.inst.theta(corrDetect,1),'Correct Detect \theta_l',cdf,1);
statsAndPlot(cv*newData.inst.theta(corrDetect,2),cv*tData.inst.theta(corrDetect,2),'Correct Detect \theta_r',cdf,1);

%% Correct Tracking
ctf = find(corrTrack); % Frame Numbers

statsAndPlot(newData.mark.subT(corrTrack,1),tData.mark.subT(corrTrack,1),'Correct Track X_{mark}',ctf);
statsAndPlot(newData.mark.subT(corrTrack,2),tData.mark.subT(corrTrack,2),'Correct Track Y_{mark}',ctf);
statsAndPlot(newData.inst.rho(corrTrack,1),tData.inst.rho(corrTrack,1),'Correct Track \rho_l',ctf,1);
statsAndPlot(newData.inst.rho(corrTrack,2),tData.inst.rho(corrTrack,2),'Correct Track \rho_r',ctf,1);
statsAndPlot(cv*newData.inst.theta(corrTrack,1),cv*tData.inst.theta(corrTrack,1),'Correct Track \theta_l',ctf,1);
statsAndPlot(cv*newData.inst.theta(corrTrack,2),cv*tData.inst.theta(corrTrack,2),'Correct Track \theta_r',ctf,1);

% Confidence Parameteres
new_ct_delta_width = diff(newData.inst.rho(ctf,:),1,2) - diff(newData.inst.rho(ctf-1,:),1,2);
new_ct_delta_orient = mean(newData.inst.theta(ctf,:),2) - mean(newData.inst.theta(ctf-1,:),2);
new_ct_delta_inliers = (newData.algoInfo.leftNumInliers(ctf) + newData.algoInfo.rightNumInliers(ctf)) - ...
                    (newData.algoInfo.leftNumInliers(ctf-1) + newData.algoInfo.rightNumInliers(ctf-1));
                
old_ct_delta_width = diff(tData.inst.rho(ctf,:),1,2) - diff(tData.inst.rho(ctf-1,:),1,2);
old_ct_delta_orient = mean(tData.inst.theta(ctf,:),2) - mean(tData.inst.theta(ctf-1,:),2);
old_ct_delta_inliers = (tData.algoInfo.leftNumInliers(ctf) + tData.algoInfo.rightNumInliers(ctf)) - ...
                    (tData.algoInfo.leftNumInliers(ctf-1) + tData.algoInfo.rightNumInliers(ctf-1));

statsAndPlot(new_ct_delta_width,old_ct_delta_width,'Correct Track \Delta Width',ctf);
statsAndPlot(new_ct_delta_orient,old_ct_delta_orient,'Correct Track \Delta Orient',ctf);
statsAndPlot(new_ct_delta_inliers,old_ct_delta_inliers,'Correct Track \Delta Inliers',ctf);

%% Tracking Error
etf = find(errTrack); % Frame Numbers

statsAndPlot(newData.mark.subT(errTrack,1),tData.mark.subT(errTrack,1),'Track Error X_{mark}',etf);
statsAndPlot(newData.mark.subT(errTrack,2),tData.mark.subT(errTrack,2),'Track Error Y_{mark}',etf);
statsAndPlot(newData.inst.rho(errTrack,1),tData.inst.rho(errTrack,1),'Track Error \rho_l',etf);
statsAndPlot(newData.inst.rho(errTrack,2),tData.inst.rho(errTrack,2),'Track Error \rho_r',etf);
statsAndPlot(cv*newData.inst.theta(errTrack,1),cv*tData.inst.theta(errTrack,1),'Track Error \theta_l',etf);
statsAndPlot(cv*newData.inst.theta(errTrack,2),cv*tData.inst.theta(errTrack,2),'Track Error \theta_r',etf);

% Confidence Parameters
new_et_delta_width = diff(newData.inst.rho(etf,:),1,2) - diff(newData.inst.rho(etf-1,:),1,2);
new_et_delta_orient = mean(newData.inst.theta(etf,:),2) - mean(newData.inst.theta(etf-1,:),2);
new_et_delta_inliers = (newData.algoInfo.leftNumInliers(etf) + newData.algoInfo.rightNumInliers(etf)) - ...
                    (newData.algoInfo.leftNumInliers(etf-1) + newData.algoInfo.rightNumInliers(etf-1));
                
old_et_delta_width = diff(tData.inst.rho(etf,:),1,2) - diff(tData.inst.rho(etf-1,:),1,2);
old_et_delta_orient = mean(tData.inst.theta(etf,:),2) - mean(tData.inst.theta(etf-1,:),2);
old_et_delta_inliers = (tData.algoInfo.leftNumInliers(etf) + tData.algoInfo.rightNumInliers(etf)) - ...
                    (tData.algoInfo.leftNumInliers(etf-1) + tData.algoInfo.rightNumInliers(etf-1));

statsAndPlot(new_et_delta_width,old_et_delta_width,'Track Error \Delta Width',etf);
statsAndPlot(new_et_delta_orient,old_et_delta_orient,'Track Error \Delta Orient',etf);
statsAndPlot(new_et_delta_inliers,old_et_delta_inliers,'Track Error \Delta Inliers',etf);

function statsAndPlot(newSignal,oldSignal,sigName,frames,plotFlag)

% Set plotFlag if not an input argument
if(nargin == 4)
    plotFlag = 0;
end

% Find NaN Frames that don't agree %
% Not agreeing is defined as : a value for the tracking parameter was found
% in the old data, but not found (error) in the new tracking.  This is
% indicated by a value being nan for the new data that is not nan in the
% old data.
numFrames = numel(frames); % Store the Total Number of Frames
newNanInf = isnan(newSignal) | isinf(newSignal);
oldNanInf = isnan(oldSignal) | isinf(oldSignal);
disagreeNanInfFrames = frames((newNanInf == 1) & (oldNanInf == 0));

% Compute Stats for diffSignal
diffSignal = newSignal - oldSignal;
frames(isnan(diffSignal) | isinf(diffSignal)) = []; % Remove NaN/Inf Frames
diffSignal(isnan(diffSignal) | isinf(diffSignal)) = []; % Remove NaN/Inf Signal

disp(sigName);
fprintf('Data Points : %u / %u (Analyze / Available)\n',numel(diffSignal),numFrames);
fprintf('Mean : %4.4f\n',mean(diffSignal));
fprintf('Max : %4.4f\n',max(diffSignal));
fprintf('Min : %4.4f\n',min(diffSignal));
disp('Nan/Inf Frames that do not agree :');
disp(disagreeNanInfFrames);
fprintf('\n');

% Plot Diff Signal
if(plotFlag == 1)
    figure('Name',sigName);
    scatter(frames,diffSignal);
    title(sigName);
end

